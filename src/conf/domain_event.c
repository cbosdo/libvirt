/*
 * domain_event.c: domain event queue processing helpers
 *
 * Copyright (C) 2010-2013 Red Hat, Inc.
 * Copyright (C) 2008 VirtualIron
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library.  If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * Author: Ben Guthro
 */

#include <config.h>

#include "domain_event.h"
#include "virlog.h"
#include "datatypes.h"
#include "viralloc.h"
#include "virerror.h"
#include "virstring.h"

#define VIR_FROM_THIS VIR_FROM_NONE

#define VIR_OBJECT_EVENT_CALLBACK(cb) ((virConnectObjectEventGenericCallback)(cb))

struct _virObjectMeta {
    int id;
    char *name;
    unsigned char uuid[VIR_UUID_BUFLEN];
};
typedef struct _virObjectMeta virObjectMeta;
typedef virObjectMeta *virObjectMetaPtr;

typedef struct _virObjectEventQueue virObjectEventQueue;
typedef virObjectEventQueue *virObjectEventQueuePtr;

struct _virObjectEventCallbackList {
    unsigned int nextID;
    unsigned int count;
    virObjectEventCallbackPtr *callbacks;
};
typedef struct _virObjectEventCallbackList virObjectEventCallbackList;
typedef virObjectEventCallbackList *virObjectEventCallbackListPtr;

struct _virObjectEventQueue {
    unsigned int count;
    virDomainEventPtr *events;
};

struct _virObjectEventState {
    /* The list of domain event callbacks */
    virObjectEventCallbackListPtr callbacks;
    /* The queue of object events */
    virObjectEventQueuePtr queue;
    /* Timer for flushing events queue */
    int timer;
    /* Flag if we're in process of dispatching */
    bool isDispatching;
    virMutex lock;
};

struct _virObjectEventCallback {
    int callbackID;
    int eventID;
    virConnectPtr conn;
    virObjectMetaPtr meta;
    virConnectObjectEventGenericCallback cb;
    void *opaque;
    virFreeCallback freecb;
    int deleted;
};



static virClassPtr virObjectEventClass;
static virClassPtr virDomainEventClass;
static virClassPtr virDomainEventLifecycleClass;
static void virObjectEventDispose(void *obj);
static void virDomainEventDispose(void *obj);
static void virDomainEventLifecycleDispose(void *obj);

struct _virObjectEvent {
    virObject parent;
    int eventID;
};

struct _virDomainEvent {
    virObjectEvent parent;

    virObjectMeta meta;

    union {
        struct {
            long long offset;
        } rtcChange;
        struct {
            int action;
        } watchdog;
        struct {
            char *srcPath;
            char *devAlias;
            int action;
            char *reason;
        } ioError;
        struct {
            int phase;
            virDomainEventGraphicsAddressPtr local;
            virDomainEventGraphicsAddressPtr remote;
            char *authScheme;
            virDomainEventGraphicsSubjectPtr subject;
        } graphics;
        struct {
            char *path;
            int type;
            int status;
        } blockJob;
        struct {
            char *oldSrcPath;
            char *newSrcPath;
            char *devAlias;
            int reason;
        } diskChange;
        struct {
            char *devAlias;
            int reason;
        } trayChange;
        struct {
            /* In unit of 1024 bytes */
            unsigned long long actual;
        } balloonChange;
        struct {
            char *devAlias;
        } deviceRemoved;
    } data;
};

struct _virDomainEventLifecycle {
    virDomainEvent parent;

    int type;
    int detail;
};
typedef struct _virDomainEventLifecycle virDomainEventLifecycle;
typedef virDomainEventLifecycle *virDomainEventLifecyclePtr;


static int virObjectEventOnceInit(void)
{
    if (!(virObjectEventClass = virClassNew(virClassForObject(),
                                             "virObjectEvent",
                                             sizeof(virObjectEvent),
                                             virObjectEventDispose)))
        return -1;
    if (!(virDomainEventClass = virClassNew(virObjectEventClass,
                                             "virDomainEvent",
                                             sizeof(virDomainEvent),
                                             virDomainEventDispose)))
        return -1;
    if (!(virDomainEventLifecycleClass = virClassNew(
                                             virDomainEventClass,
                                             "virDomainEventLifecycle",
                                             sizeof(virDomainEventLifecycle),
                                             virDomainEventLifecycleDispose)))
        return -1;
    return 0;
}

VIR_ONCE_GLOBAL_INIT(virObjectEvent)

static int virObjectEventGetEventID(void *anyobj)
{
    virObjectEventPtr obj = anyobj;

    if (!virObjectIsClass(obj, virObjectEventClass)) {
        VIR_WARN("Object %p (%s) is not a virObjectEvent instance",
                 obj, obj ? virClassName(obj->parent.klass) : "(unknown)");
        return -1;
    }
    return obj->eventID;
}

static void virObjectEventDispose(void *obj)
{
    virObjectEventPtr event = obj;

    VIR_DEBUG("obj=%p", event);
}

static void virDomainEventDispose(void *obj)
{
    virDomainEventPtr event = obj;

    VIR_DEBUG("obj=%p", event);

    switch (virObjectEventGetEventID(event)) {
    case VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON:
    case VIR_DOMAIN_EVENT_ID_IO_ERROR:
        VIR_FREE(event->data.ioError.srcPath);
        VIR_FREE(event->data.ioError.devAlias);
        VIR_FREE(event->data.ioError.reason);
        break;

    case VIR_DOMAIN_EVENT_ID_GRAPHICS:
        if (event->data.graphics.local) {
            VIR_FREE(event->data.graphics.local->node);
            VIR_FREE(event->data.graphics.local->service);
            VIR_FREE(event->data.graphics.local);
        }
        if (event->data.graphics.remote) {
            VIR_FREE(event->data.graphics.remote->node);
            VIR_FREE(event->data.graphics.remote->service);
            VIR_FREE(event->data.graphics.remote);
        }
        VIR_FREE(event->data.graphics.authScheme);
        if (event->data.graphics.subject) {
            size_t i;
            for (i = 0; i < event->data.graphics.subject->nidentity; i++) {
                VIR_FREE(event->data.graphics.subject->identities[i].type);
                VIR_FREE(event->data.graphics.subject->identities[i].name);
            }
            VIR_FREE(event->data.graphics.subject);
        }
        break;

    case VIR_DOMAIN_EVENT_ID_BLOCK_JOB:
        VIR_FREE(event->data.blockJob.path);
        break;

    case VIR_DOMAIN_EVENT_ID_DISK_CHANGE:
        VIR_FREE(event->data.diskChange.oldSrcPath);
        VIR_FREE(event->data.diskChange.newSrcPath);
        VIR_FREE(event->data.diskChange.devAlias);
        break;
    case VIR_DOMAIN_EVENT_ID_TRAY_CHANGE:
        VIR_FREE(event->data.trayChange.devAlias);
        break;
    case VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED:
        VIR_FREE(event->data.deviceRemoved.devAlias);
        break;
    }

    VIR_FREE(event->meta.name);
}

static void virDomainEventLifecycleDispose(void *obj)
{
    virDomainEventLifecyclePtr event = obj;
    VIR_DEBUG("obj=%p", event);
}

/**
 * virObjectEventCallbackListFree:
 * @list: event callback list head
 *
 * Free the memory in the domain event callback list
 */
static void
virObjectEventCallbackListFree(virObjectEventCallbackListPtr list)
{
    size_t i;
    if (!list)
        return;

    for (i=0; i<list->count; i++) {
        virFreeCallback freecb = list->callbacks[i]->freecb;
        if (freecb)
            (*freecb)(list->callbacks[i]->opaque);
        VIR_FREE(list->callbacks[i]);
    }
    VIR_FREE(list->callbacks);
    VIR_FREE(list);
}


/**
 * virDomainEventCallbackListRemove:
 * @conn: pointer to the connection
 * @cbList: the list
 * @callback: the callback to remove
 *
 * Internal function to remove a callback from a virObjectEventCallbackListPtr
 */
static int
virDomainEventCallbackListRemove(virConnectPtr conn,
                                 virObjectEventCallbackListPtr cbList,
                                 virConnectDomainEventCallback callback)
{
    int ret = 0;
    size_t i;
    for (i = 0; i < cbList->count; i++) {
        if (cbList->callbacks[i]->cb == VIR_OBJECT_EVENT_CALLBACK(callback) &&
            cbList->callbacks[i]->eventID == VIR_DOMAIN_EVENT_ID_LIFECYCLE &&
            cbList->callbacks[i]->conn == conn) {
            virFreeCallback freecb = cbList->callbacks[i]->freecb;
            if (freecb)
                (*freecb)(cbList->callbacks[i]->opaque);
            virObjectUnref(cbList->callbacks[i]->conn);
            VIR_FREE(cbList->callbacks[i]);

            if (i < (cbList->count - 1))
                memmove(cbList->callbacks + i,
                        cbList->callbacks + i + 1,
                        sizeof(*(cbList->callbacks)) *
                                (cbList->count - (i + 1)));

            if (VIR_REALLOC_N(cbList->callbacks,
                              cbList->count - 1) < 0) {
                ; /* Failure to reduce memory allocation isn't fatal */
            }
            cbList->count--;

            for (i = 0; i < cbList->count; i++) {
                if (!cbList->callbacks[i]->deleted)
                    ret++;
            }
            return ret;
        }
    }

    virReportError(VIR_ERR_INTERNAL_ERROR, "%s",
                   _("could not find event callback for removal"));
    return -1;
}


/**
 * virObjectEventCallbackListRemoveID:
 * @conn: pointer to the connection
 * @cbList: the list
 * @callback: the callback to remove
 *
 * Internal function to remove a callback from a virObjectEventCallbackListPtr
 */
static int
virObjectEventCallbackListRemoveID(virConnectPtr conn,
                                   virObjectEventCallbackListPtr cbList,
                                   int callbackID)
{
    int ret = 0;
    size_t i;
    for (i = 0; i < cbList->count; i++) {
        if (cbList->callbacks[i]->callbackID == callbackID &&
            cbList->callbacks[i]->conn == conn) {
            virFreeCallback freecb = cbList->callbacks[i]->freecb;
            if (freecb)
                (*freecb)(cbList->callbacks[i]->opaque);
            virObjectUnref(cbList->callbacks[i]->conn);
            VIR_FREE(cbList->callbacks[i]);

            if (i < (cbList->count - 1))
                memmove(cbList->callbacks + i,
                        cbList->callbacks + i + 1,
                        sizeof(*(cbList->callbacks)) *
                                (cbList->count - (i + 1)));

            if (VIR_REALLOC_N(cbList->callbacks,
                              cbList->count - 1) < 0) {
                ; /* Failure to reduce memory allocation isn't fatal */
            }
            cbList->count--;

            for (i = 0; i < cbList->count; i++) {
                if (!cbList->callbacks[i]->deleted)
                    ret++;
            }
            return ret;
        }
    }

    virReportError(VIR_ERR_INTERNAL_ERROR, "%s",
                   _("could not find event callback for removal"));
    return -1;
}


static int
virDomainEventCallbackListMarkDelete(virConnectPtr conn,
                                     virObjectEventCallbackListPtr cbList,
                                     virConnectDomainEventCallback callback)
{
    int ret = 0;
    size_t i;
    for (i = 0; i < cbList->count; i++) {
        if (cbList->callbacks[i]->cb == VIR_OBJECT_EVENT_CALLBACK(callback) &&
            cbList->callbacks[i]->eventID == VIR_DOMAIN_EVENT_ID_LIFECYCLE &&
            cbList->callbacks[i]->conn == conn) {
            cbList->callbacks[i]->deleted = 1;
            for (i = 0; i < cbList->count; i++) {
                if (!cbList->callbacks[i]->deleted)
                    ret++;
            }
            return ret;
        }
    }

    virReportError(VIR_ERR_INTERNAL_ERROR, "%s",
                   _("could not find event callback for deletion"));
    return -1;
}


static int
virObjectEventCallbackListMarkDeleteID(virConnectPtr conn,
                                       virObjectEventCallbackListPtr cbList,
                                       int callbackID)
{
    int ret = 0;
    size_t i;
    for (i = 0; i < cbList->count; i++) {
        if (cbList->callbacks[i]->callbackID == callbackID &&
            cbList->callbacks[i]->conn == conn) {
            cbList->callbacks[i]->deleted = 1;
            for (i = 0; i < cbList->count; i++) {
                if (!cbList->callbacks[i]->deleted)
                    ret++;
            }
            return ret;
        }
    }

    virReportError(VIR_ERR_INTERNAL_ERROR, "%s",
                   _("could not find event callback for deletion"));
    return -1;
}


static int
virObjectEventCallbackListPurgeMarked(virObjectEventCallbackListPtr cbList)
{
    int old_count = cbList->count;
    int n;
    for (n = 0; n < cbList->count; n++) {
        if (cbList->callbacks[n]->deleted) {
            virFreeCallback freecb = cbList->callbacks[n]->freecb;
            if (freecb)
                (*freecb)(cbList->callbacks[n]->opaque);
            virObjectUnref(cbList->callbacks[n]->conn);
            VIR_FREE(cbList->callbacks[n]);

            if (n < (cbList->count - 1))
                memmove(cbList->callbacks + n,
                        cbList->callbacks + n + 1,
                        sizeof(*(cbList->callbacks)) *
                                (cbList->count - (n + 1)));
            cbList->count--;
            n--;
        }
    }
    if (cbList->count < old_count &&
        VIR_REALLOC_N(cbList->callbacks, cbList->count) < 0) {
        ; /* Failure to reduce memory allocation isn't fatal */
    }
    return 0;
}


/**
 * virObjectEventCallbackListAddID:
 * @conn: pointer to the connection
 * @cbList: the list
 * @uuid: the uuid of the object to filter on
 * @name: the name of the object to filter on
 * @id: the ID of the object to filter on
 * @eventID: the event ID
 * @callback: the callback to add
 * @opaque: opaque data tio pass to callback
 * @callbackID: filled with callback ID
 *
 * Internal function to add a callback from a virObjectEventCallbackListPtr
 */
static int
virObjectEventCallbackListAddID(virConnectPtr conn,
                                virObjectEventCallbackListPtr cbList,
                                unsigned char uuid[VIR_UUID_BUFLEN],
                                const char *name,
                                int id,
                                int eventID,
                                virConnectObjectEventGenericCallback callback,
                                void *opaque,
                                virFreeCallback freecb,
                                int *callbackID)
{
    virObjectEventCallbackPtr event;
    size_t i;
    int ret = 0;

    /* Check incoming */
    if (!cbList) {
        return -1;
    }

    /* check if we already have this callback on our list */
    for (i = 0; i < cbList->count; i++) {
        if (cbList->callbacks[i]->cb == VIR_OBJECT_EVENT_CALLBACK(callback) &&
            cbList->callbacks[i]->eventID == eventID &&
            cbList->callbacks[i]->conn == conn &&
            ((uuid && cbList->callbacks[i]->meta &&
              memcmp(cbList->callbacks[i]->meta->uuid,
                     uuid, VIR_UUID_BUFLEN) == 0) ||
             (!uuid && !cbList->callbacks[i]->meta))) {
            virReportError(VIR_ERR_INTERNAL_ERROR, "%s",
                           _("event callback already tracked"));
            return -1;
        }
    }
    /* Allocate new event */
    if (VIR_ALLOC(event) < 0)
        goto error;
    event->conn = conn;
    event->cb = callback;
    event->eventID = eventID;
    event->opaque = opaque;
    event->freecb = freecb;

    if (name && uuid && id > 0) {
        if (VIR_ALLOC(event->meta) < 0)
            goto error;
        if (VIR_STRDUP(event->meta->name, name) < 0)
            goto error;
        memcpy(event->meta->uuid, uuid, VIR_UUID_BUFLEN);
        event->meta->id = id;
    }

    /* Make space on list */
    if (VIR_REALLOC_N(cbList->callbacks, cbList->count + 1) < 0)
        goto error;

    virObjectRef(event->conn);

    cbList->callbacks[cbList->count] = event;
    cbList->count++;

    event->callbackID = cbList->nextID++;

    for (i = 0; i < cbList->count; i++) {
        if (cbList->callbacks[i]->eventID == eventID &&
            cbList->callbacks[i]->conn == conn &&
            !cbList->callbacks[i]->deleted)
            ret++;
    }

    if (callbackID)
        *callbackID = event->callbackID;

    return ret;

error:
    if (event) {
        if (event->meta)
            VIR_FREE(event->meta->name);
        VIR_FREE(event->meta);
    }
    VIR_FREE(event);
    return -1;
}


/**
 * virDomainEventCallbackListAdd:
 * @conn: pointer to the connection
 * @cbList: the list
 * @callback: the callback to add
 * @opaque: opaque data tio pass to callback
 *
 * Internal function to add a callback from a virObjectEventCallbackListPtr
 */
static int
virDomainEventCallbackListAdd(virConnectPtr conn,
                              virObjectEventCallbackListPtr cbList,
                              virConnectDomainEventCallback callback,
                              void *opaque,
                              virFreeCallback freecb)
{
    return virObjectEventCallbackListAddID(conn, cbList, NULL, NULL, 0,
                                           VIR_DOMAIN_EVENT_ID_LIFECYCLE,
                                           VIR_OBJECT_EVENT_CALLBACK(callback),
                                           opaque, freecb, NULL);
}



static int
virObjectEventCallbackListEventID(virConnectPtr conn,
                                  virObjectEventCallbackListPtr cbList,
                                  int callbackID)
{
    size_t i;

    for (i = 0; i < cbList->count; i++) {
        if (cbList->callbacks[i]->deleted)
            continue;

        if (cbList->callbacks[i]->callbackID == callbackID &&
            cbList->callbacks[i]->conn == conn)
            return cbList->callbacks[i]->eventID;
    }

    return -1;
}


/**
 * virObjectEventQueueClear:
 * @queue: pointer to the queue
 *
 * Removes all elements from the queue
 */
static void
virObjectEventQueueClear(virObjectEventQueuePtr queue)
{
    size_t i;
    if (!queue)
        return;

    for (i = 0; i < queue->count; i++) {
        virObjectUnref(queue->events[i]);
    }
    VIR_FREE(queue->events);
    queue->count = 0;
}

/**
 * virObjectEventQueueFree:
 * @queue: pointer to the queue
 *
 * Free the memory in the queue. We process this like a list here
 */
static void
virObjectEventQueueFree(virObjectEventQueuePtr queue)
{
    if (!queue)
        return;

    virObjectEventQueueClear(queue);
    VIR_FREE(queue);
}

static virObjectEventQueuePtr
virObjectEventQueueNew(void)
{
    virObjectEventQueuePtr ret;

    ignore_value(VIR_ALLOC(ret));
    return ret;
}

static void
virObjectEventStateLock(virObjectEventStatePtr state)
{
    virMutexLock(&state->lock);
}

static void
virObjectEventStateUnlock(virObjectEventStatePtr state)
{
    virMutexUnlock(&state->lock);
}

/**
 * virObjectEventStateFree:
 * @list: virObjectEventStatePtr to free
 *
 * Free a virObjectEventStatePtr and its members, and unregister the timer.
 */
void
virObjectEventStateFree(virObjectEventStatePtr state)
{
    if (!state)
        return;

    virObjectEventCallbackListFree(state->callbacks);
    virObjectEventQueueFree(state->queue);

    if (state->timer != -1)
        virEventRemoveTimeout(state->timer);

    virMutexDestroy(&state->lock);
    VIR_FREE(state);
}


static void virObjectEventStateFlush(virObjectEventStatePtr state);

static void
virDomainEventTimer(int timer ATTRIBUTE_UNUSED, void *opaque)
{
    virObjectEventStatePtr state = opaque;

    virObjectEventStateFlush(state);
}

/**
 * virObjectEventStateNew:
 */
virObjectEventStatePtr
virObjectEventStateNew(void)
{
    virObjectEventStatePtr state = NULL;

    if (VIR_ALLOC(state) < 0)
        goto error;

    if (virMutexInit(&state->lock) < 0) {
        virReportSystemError(errno, "%s",
                             _("unable to initialize state mutex"));
        VIR_FREE(state);
        goto error;
    }

    if (VIR_ALLOC(state->callbacks) < 0)
        goto error;

    if (!(state->queue = virObjectEventQueueNew()))
        goto error;

    state->timer = -1;

    return state;

error:
    virObjectEventStateFree(state);
    return NULL;
}

static void *virObjectEventNew(virClassPtr klass,
                               int eventID)
{
    virObjectEventPtr event;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!virClassIsDerivedFrom(klass, virObjectEventClass)) {
        virReportInvalidArg(klass,
                            _("Class %s must derive from virObjectEvent"),
                            virClassName(klass));
        return NULL;
    }

    if (!(event = virObjectNew(klass)))
        return NULL;

    event->eventID = eventID;

    VIR_DEBUG("obj=%p", event);
    return event;
}

static void *virDomainEventNewInternal(virClassPtr klass,
                                       int eventID,
                                       int id,
                                       const char *name,
                                       const unsigned char *uuid)
{
    virDomainEventPtr event;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!virClassIsDerivedFrom(klass, virDomainEventClass)) {
        virReportInvalidArg(klass,
                            _("Class %s must derive from virDomainEvent"),
                            virClassName(klass));
        return NULL;
    }

    if (!(event = virObjectEventNew(klass, eventID)))
        return NULL;

    if (VIR_STRDUP(event->meta.name, name) < 0) {
        VIR_FREE(event);
        return NULL;
    }
    event->meta.id = id;
    memcpy(event->meta.uuid, uuid, VIR_UUID_BUFLEN);

    return event;
}

virDomainEventPtr virDomainEventLifecycleNew(int id, const char *name,
                                    const unsigned char *uuid,
                                    int type, int detail)
{
    virDomainEventLifecyclePtr event;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(event = virDomainEventNewInternal(virDomainEventLifecycleClass,
                                            VIR_DOMAIN_EVENT_ID_LIFECYCLE,
                                            id, name, uuid)))
        return NULL;

    event->type = type;
    event->detail = detail;

    return (virDomainEventPtr)event;
}

virDomainEventPtr virDomainEventLifecycleNewFromDom(virDomainPtr dom, int type, int detail)
{
    return virDomainEventLifecycleNew(dom->id, dom->name, dom->uuid,
                                      type, detail);
}

virDomainEventPtr virDomainEventLifecycleNewFromObj(virDomainObjPtr obj, int type, int detail)
{
    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);
}

virDomainEventPtr virDomainEventLifecycleNewFromDef(virDomainDefPtr def, int type, int detail)
{
    return virDomainEventLifecycleNew(def->id, def->name, def->uuid,
                                      type, detail);
}

virDomainEventPtr virDomainEventRebootNew(int id, const char *name,
                                          const unsigned char *uuid)
{
    if (virObjectEventInitialize() < 0)
        return NULL;

    return virDomainEventNewInternal(virDomainEventClass,
                                     VIR_DOMAIN_EVENT_ID_REBOOT,
                                     id, name, uuid);
}

virDomainEventPtr virDomainEventRebootNewFromDom(virDomainPtr dom)
{
    if (virObjectEventInitialize() < 0)
        return NULL;

    return virDomainEventNewInternal(virDomainEventClass,
                                     VIR_DOMAIN_EVENT_ID_REBOOT,
                                     dom->id, dom->name, dom->uuid);
}

virDomainEventPtr virDomainEventRebootNewFromObj(virDomainObjPtr obj)
{
    if (virObjectEventInitialize() < 0)
        return NULL;

    return virDomainEventNewInternal(virDomainEventClass,
                                     VIR_DOMAIN_EVENT_ID_REBOOT,
                                     obj->def->id, obj->def->name, obj->def->uuid);
}

virDomainEventPtr virDomainEventRTCChangeNewFromDom(virDomainPtr dom,
                                                    long long offset)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass,
                                         VIR_DOMAIN_EVENT_ID_RTC_CHANGE,
                                         dom->id, dom->name, dom->uuid)))
        return NULL;

    ev->data.rtcChange.offset = offset;

    return ev;
}
virDomainEventPtr virDomainEventRTCChangeNewFromObj(virDomainObjPtr obj,
                                                    long long offset)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass,
                                         VIR_DOMAIN_EVENT_ID_RTC_CHANGE,
                                         obj->def->id, obj->def->name,
                                         obj->def->uuid)))
        return NULL;

    ev->data.rtcChange.offset = offset;

    return ev;
}

virDomainEventPtr virDomainEventWatchdogNewFromDom(virDomainPtr dom,
                                                   int action)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass,
                                         VIR_DOMAIN_EVENT_ID_WATCHDOG,
                                         dom->id, dom->name, dom->uuid)))
        return NULL;

    ev->data.watchdog.action = action;

    return ev;
}
virDomainEventPtr virDomainEventWatchdogNewFromObj(virDomainObjPtr obj,
                                                   int action)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass,
                                         VIR_DOMAIN_EVENT_ID_WATCHDOG,
                                         obj->def->id, obj->def->name,
                                         obj->def->uuid)))
        return NULL;

    ev->data.watchdog.action = action;

    return ev;
}

static virDomainEventPtr virDomainEventIOErrorNewFromDomImpl(int event,
                                                             virDomainPtr dom,
                                                             const char *srcPath,
                                                             const char *devAlias,
                                                             int action,
                                                             const char *reason)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass, event,
                                         dom->id, dom->name, dom->uuid)))
        return NULL;

    ev->data.ioError.action = action;
    if (VIR_STRDUP(ev->data.ioError.srcPath, srcPath) < 0 ||
        VIR_STRDUP(ev->data.ioError.devAlias, devAlias) < 0 ||
        VIR_STRDUP(ev->data.ioError.reason, reason) < 0) {
        virObjectUnref(ev);
        ev = NULL;
    }

    return ev;
}

static virDomainEventPtr virDomainEventIOErrorNewFromObjImpl(int event,
                                                             virDomainObjPtr obj,
                                                             const char *srcPath,
                                                             const char *devAlias,
                                                             int action,
                                                             const char *reason)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass, event,
                                         obj->def->id, obj->def->name,
                                         obj->def->uuid)))
        return NULL;

    ev->data.ioError.action = action;
    if (VIR_STRDUP(ev->data.ioError.srcPath, srcPath) < 0 ||
        VIR_STRDUP(ev->data.ioError.devAlias, devAlias) < 0 ||
        VIR_STRDUP(ev->data.ioError.reason, reason) < 0) {
        virObjectUnref(ev);
        ev = NULL;
    }

    return ev;
}

virDomainEventPtr virDomainEventIOErrorNewFromDom(virDomainPtr dom,
                                                  const char *srcPath,
                                                  const char *devAlias,
                                                  int action)
{
    return virDomainEventIOErrorNewFromDomImpl(VIR_DOMAIN_EVENT_ID_IO_ERROR,
                                               dom, srcPath, devAlias,
                                               action, NULL);
}

virDomainEventPtr virDomainEventIOErrorNewFromObj(virDomainObjPtr obj,
                                                  const char *srcPath,
                                                  const char *devAlias,
                                                  int action)
{
    return virDomainEventIOErrorNewFromObjImpl(VIR_DOMAIN_EVENT_ID_IO_ERROR,
                                               obj, srcPath, devAlias,
                                               action, NULL);
}

virDomainEventPtr virDomainEventIOErrorReasonNewFromDom(virDomainPtr dom,
                                                        const char *srcPath,
                                                        const char *devAlias,
                                                        int action,
                                                        const char *reason)
{
    return virDomainEventIOErrorNewFromDomImpl(VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON,
                                               dom, srcPath, devAlias,
                                               action, reason);
}

virDomainEventPtr virDomainEventIOErrorReasonNewFromObj(virDomainObjPtr obj,
                                                        const char *srcPath,
                                                        const char *devAlias,
                                                        int action,
                                                        const char *reason)
{
    return virDomainEventIOErrorNewFromObjImpl(VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON,
                                               obj, srcPath, devAlias,
                                               action, reason);
}


virDomainEventPtr virDomainEventGraphicsNewFromDom(virDomainPtr dom,
                                                   int phase,
                                                   virDomainEventGraphicsAddressPtr local,
                                                   virDomainEventGraphicsAddressPtr remote,
                                                   const char *authScheme,
                                                   virDomainEventGraphicsSubjectPtr subject)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass,
                                         VIR_DOMAIN_EVENT_ID_GRAPHICS,
                                         dom->id, dom->name, dom->uuid)))
        return NULL;

    ev->data.graphics.phase = phase;
    if (VIR_STRDUP(ev->data.graphics.authScheme, authScheme) < 0) {
        virObjectUnref(ev);
        return NULL;
    }
    ev->data.graphics.local = local;
    ev->data.graphics.remote = remote;
    ev->data.graphics.subject = subject;

    return ev;
}

virDomainEventPtr virDomainEventGraphicsNewFromObj(virDomainObjPtr obj,
                                                   int phase,
                                                   virDomainEventGraphicsAddressPtr local,
                                                   virDomainEventGraphicsAddressPtr remote,
                                                   const char *authScheme,
                                                   virDomainEventGraphicsSubjectPtr subject)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass,
                                         VIR_DOMAIN_EVENT_ID_GRAPHICS,
                                         obj->def->id, obj->def->name,
                                         obj->def->uuid)))
        return NULL;

    ev->data.graphics.phase = phase;
    if (VIR_STRDUP(ev->data.graphics.authScheme, authScheme) < 0) {
        virObjectUnref(ev);
        return NULL;
    }
    ev->data.graphics.local = local;
    ev->data.graphics.remote = remote;
    ev->data.graphics.subject = subject;

    return ev;
}

static virDomainEventPtr
virDomainEventBlockJobNew(int id, const char *name, unsigned char *uuid,
                          const char *path, int type, int status)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass,
                                         VIR_DOMAIN_EVENT_ID_BLOCK_JOB,
                                         id, name, uuid)))
        return NULL;

    if (VIR_STRDUP(ev->data.blockJob.path, path) < 0) {
        virObjectUnref(ev);
        return NULL;
    }
    ev->data.blockJob.type = type;
    ev->data.blockJob.status = status;

    return ev;
}

virDomainEventPtr virDomainEventBlockJobNewFromObj(virDomainObjPtr obj,
                                                   const char *path,
                                                   int type,
                                                   int status)
{
    return virDomainEventBlockJobNew(obj->def->id, obj->def->name,
                                     obj->def->uuid, path, type, status);
}

virDomainEventPtr virDomainEventBlockJobNewFromDom(virDomainPtr dom,
                                                   const char *path,
                                                   int type,
                                                   int status)
{
    return virDomainEventBlockJobNew(dom->id, dom->name, dom->uuid,
                                     path, type, status);
}

virDomainEventPtr virDomainEventControlErrorNewFromDom(virDomainPtr dom)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass,
                                         VIR_DOMAIN_EVENT_ID_CONTROL_ERROR,
                                         dom->id, dom->name, dom->uuid)))
        return NULL;
    return ev;
}


virDomainEventPtr virDomainEventControlErrorNewFromObj(virDomainObjPtr obj)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass,
                                         VIR_DOMAIN_EVENT_ID_CONTROL_ERROR,
                                         obj->def->id, obj->def->name,
                                         obj->def->uuid)))
        return NULL;
    return ev;
}

static virDomainEventPtr
virDomainEventDiskChangeNew(int id, const char *name,
                            unsigned char *uuid,
                            const char *oldSrcPath,
                            const char *newSrcPath,
                            const char *devAlias, int reason)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass,
                                         VIR_DOMAIN_EVENT_ID_DISK_CHANGE,
                                         id, name, uuid)))
        return NULL;

    if (VIR_STRDUP(ev->data.diskChange.devAlias, devAlias) < 0)
        goto error;

    if (VIR_STRDUP(ev->data.diskChange.oldSrcPath, oldSrcPath) < 0)
        goto error;

    if (VIR_STRDUP(ev->data.diskChange.newSrcPath, newSrcPath) < 0)
        goto error;

    ev->data.diskChange.reason = reason;

    return ev;

error:
    virObjectUnref(ev);
    return NULL;
}

virDomainEventPtr virDomainEventDiskChangeNewFromObj(virDomainObjPtr obj,
                                                     const char *oldSrcPath,
                                                     const char *newSrcPath,
                                                     const char *devAlias,
                                                     int reason)
{
    return virDomainEventDiskChangeNew(obj->def->id, obj->def->name,
                                       obj->def->uuid, oldSrcPath,
                                       newSrcPath, devAlias, reason);
}

virDomainEventPtr virDomainEventDiskChangeNewFromDom(virDomainPtr dom,
                                                     const char *oldSrcPath,
                                                     const char *newSrcPath,
                                                     const char *devAlias,
                                                     int reason)
{
    return virDomainEventDiskChangeNew(dom->id, dom->name, dom->uuid,
                                       oldSrcPath, newSrcPath,
                                       devAlias, reason);
}

static virDomainEventPtr
virDomainEventTrayChangeNew(int id, const char *name,
                            unsigned char *uuid,
                            const char *devAlias,
                            int reason)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass,
                                         VIR_DOMAIN_EVENT_ID_TRAY_CHANGE,
                                         id, name, uuid)))
        return NULL;

    if (VIR_STRDUP(ev->data.trayChange.devAlias, devAlias) < 0)
        goto error;

    ev->data.trayChange.reason = reason;

    return ev;

error:
    virObjectUnref(ev);
    return NULL;
}

virDomainEventPtr virDomainEventTrayChangeNewFromObj(virDomainObjPtr obj,
                                                     const char *devAlias,
                                                     int reason)
{
    return virDomainEventTrayChangeNew(obj->def->id,
                                       obj->def->name,
                                       obj->def->uuid,
                                       devAlias,
                                       reason);
}

virDomainEventPtr virDomainEventTrayChangeNewFromDom(virDomainPtr dom,
                                                     const char *devAlias,
                                                     int reason)
{
    return virDomainEventTrayChangeNew(dom->id, dom->name, dom->uuid,
                                       devAlias, reason);
}

static virDomainEventPtr
virDomainEventPMWakeupNew(int id, const char *name,
                          unsigned char *uuid)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass,
                                         VIR_DOMAIN_EVENT_ID_PMWAKEUP,
                                         id, name, uuid)))
        return NULL;

    return ev;
}

virDomainEventPtr
virDomainEventPMWakeupNewFromObj(virDomainObjPtr obj)
{
    return virDomainEventPMWakeupNew(obj->def->id,
                                     obj->def->name,
                                     obj->def->uuid);
}

virDomainEventPtr
virDomainEventPMWakeupNewFromDom(virDomainPtr dom)
{
    return virDomainEventPMWakeupNew(dom->id, dom->name, dom->uuid);
}

static virDomainEventPtr
virDomainEventPMSuspendNew(int id, const char *name,
                           unsigned char *uuid)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass,
                                         VIR_DOMAIN_EVENT_ID_PMSUSPEND,
                                         id, name, uuid)))
        return NULL;

    return ev;
}

virDomainEventPtr
virDomainEventPMSuspendNewFromObj(virDomainObjPtr obj)
{
    return virDomainEventPMSuspendNew(obj->def->id,
                                      obj->def->name,
                                      obj->def->uuid);
}

virDomainEventPtr
virDomainEventPMSuspendNewFromDom(virDomainPtr dom)
{
    return virDomainEventPMSuspendNew(dom->id, dom->name, dom->uuid);
}

static virDomainEventPtr
virDomainEventPMSuspendDiskNew(int id, const char *name,
                               unsigned char *uuid)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass,
                                  VIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK,
                                  id, name, uuid)))
        return NULL;
    return ev;
}

virDomainEventPtr
virDomainEventPMSuspendDiskNewFromObj(virDomainObjPtr obj)
{
    return virDomainEventPMSuspendDiskNew(obj->def->id,
                                          obj->def->name,
                                          obj->def->uuid);
}

virDomainEventPtr
virDomainEventPMSuspendDiskNewFromDom(virDomainPtr dom)
{
    return virDomainEventPMSuspendDiskNew(dom->id, dom->name, dom->uuid);
}

virDomainEventPtr virDomainEventBalloonChangeNewFromDom(virDomainPtr dom,
                                                        unsigned long long actual)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass,
                                         VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE,
                                         dom->id, dom->name, dom->uuid)))
        return NULL;

    ev->data.balloonChange.actual = actual;

    return ev;
}
virDomainEventPtr virDomainEventBalloonChangeNewFromObj(virDomainObjPtr obj,
                                                        unsigned long long actual)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass,
                                         VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE,
                                         obj->def->id, obj->def->name, obj->def->uuid)))
        return NULL;

    ev->data.balloonChange.actual = actual;

    return ev;
}

static virDomainEventPtr
virDomainEventDeviceRemovedNew(int id,
                               const char *name,
                               unsigned char *uuid,
                               const char *devAlias)
{
    virDomainEventPtr ev;

    if (virObjectEventInitialize() < 0)
        return NULL;

    if (!(ev = virDomainEventNewInternal(virDomainEventClass,
                                         VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED,
                                         id, name, uuid)))
        return NULL;

    if (VIR_STRDUP(ev->data.deviceRemoved.devAlias, devAlias) < 0)
        goto error;

    return ev;

error:
    virObjectUnref(ev);
    return NULL;
}

virDomainEventPtr
virDomainEventDeviceRemovedNewFromObj(virDomainObjPtr obj,
                                      const char *devAlias)
{
    return virDomainEventDeviceRemovedNew(obj->def->id, obj->def->name,
                                          obj->def->uuid, devAlias);
}

virDomainEventPtr
virDomainEventDeviceRemovedNewFromDom(virDomainPtr dom,
                                      const char *devAlias)
{
    return virDomainEventDeviceRemovedNew(dom->id, dom->name, dom->uuid,
                                          devAlias);
}

/**
 * virObjectEventQueuePush:
 * @evtQueue: the object event queue
 * @event: the event to add
 *
 * Internal function to push to the back of a virObjectEventQueue
 *
 * Returns: 0 on success, -1 on failure
 */
static int
virObjectEventQueuePush(virObjectEventQueuePtr evtQueue,
                        virDomainEventPtr event)
{
    if (!evtQueue) {
        return -1;
    }

    /* Make space on queue */
    if (VIR_REALLOC_N(evtQueue->events,
                      evtQueue->count + 1) < 0)
        return -1;

    evtQueue->events[evtQueue->count] = event;
    evtQueue->count++;
    return 0;
}


typedef void (*virObjectEventDispatchFunc)(virConnectPtr conn,
                                           virDomainEventPtr event,
                                           virConnectObjectEventGenericCallback cb,
                                           void *cbopaque,
                                           void *opaque);


static void
virDomainEventDispatchDefaultFunc(virConnectPtr conn,
                                  virDomainEventPtr event,
                                  virConnectDomainEventGenericCallback cb,
                                  void *cbopaque,
                                  void *opaque ATTRIBUTE_UNUSED)
{
    virDomainPtr dom = virGetDomain(conn, event->meta.name, event->meta.uuid);
    int eventID = virObjectEventGetEventID(event);
    if (!dom)
        return;
    dom->id = event->meta.id;

    switch ((virDomainEventID) eventID) {
    case VIR_DOMAIN_EVENT_ID_LIFECYCLE:
        {
            virDomainEventLifecyclePtr lifecycleEvent;

            lifecycleEvent = (virDomainEventLifecyclePtr)event;
            ((virConnectDomainEventCallback)cb)(conn, dom,
                                                lifecycleEvent->type,
                                                lifecycleEvent->detail,
                                                cbopaque);
            goto cleanup;
        }

    case VIR_DOMAIN_EVENT_ID_REBOOT:
        (cb)(conn, dom,
             cbopaque);
        goto cleanup;

    case VIR_DOMAIN_EVENT_ID_RTC_CHANGE:
        ((virConnectDomainEventRTCChangeCallback)cb)(conn, dom,
                                                     event->data.rtcChange.offset,
                                                     cbopaque);
        goto cleanup;

    case VIR_DOMAIN_EVENT_ID_WATCHDOG:
        ((virConnectDomainEventWatchdogCallback)cb)(conn, dom,
                                                    event->data.watchdog.action,
                                                    cbopaque);
        goto cleanup;

    case VIR_DOMAIN_EVENT_ID_IO_ERROR:
        ((virConnectDomainEventIOErrorCallback)cb)(conn, dom,
                                                   event->data.ioError.srcPath,
                                                   event->data.ioError.devAlias,
                                                   event->data.ioError.action,
                                                   cbopaque);
        goto cleanup;

    case VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON:
        ((virConnectDomainEventIOErrorReasonCallback)cb)(conn, dom,
                                                         event->data.ioError.srcPath,
                                                         event->data.ioError.devAlias,
                                                         event->data.ioError.action,
                                                         event->data.ioError.reason,
                                                         cbopaque);
        goto cleanup;

    case VIR_DOMAIN_EVENT_ID_GRAPHICS:
        ((virConnectDomainEventGraphicsCallback)cb)(conn, dom,
                                                    event->data.graphics.phase,
                                                    event->data.graphics.local,
                                                    event->data.graphics.remote,
                                                    event->data.graphics.authScheme,
                                                    event->data.graphics.subject,
                                                    cbopaque);
        goto cleanup;

    case VIR_DOMAIN_EVENT_ID_CONTROL_ERROR:
        (cb)(conn, dom,
             cbopaque);
        goto cleanup;

    case VIR_DOMAIN_EVENT_ID_BLOCK_JOB:
        ((virConnectDomainEventBlockJobCallback)cb)(conn, dom,
                                                    event->data.blockJob.path,
                                                    event->data.blockJob.type,
                                                    event->data.blockJob.status,
                                                    cbopaque);
        goto cleanup;

    case VIR_DOMAIN_EVENT_ID_DISK_CHANGE:
        ((virConnectDomainEventDiskChangeCallback)cb)(conn, dom,
                                                      event->data.diskChange.oldSrcPath,
                                                      event->data.diskChange.newSrcPath,
                                                      event->data.diskChange.devAlias,
                                                      event->data.diskChange.reason,
                                                      cbopaque);
        goto cleanup;

    case VIR_DOMAIN_EVENT_ID_TRAY_CHANGE:
        ((virConnectDomainEventTrayChangeCallback)cb)(conn, dom,
                                                      event->data.trayChange.devAlias,
                                                      event->data.trayChange.reason,
                                                      cbopaque);
        goto cleanup;

    case VIR_DOMAIN_EVENT_ID_PMWAKEUP:
        ((virConnectDomainEventPMWakeupCallback)cb)(conn, dom, 0, cbopaque);
        goto cleanup;

    case VIR_DOMAIN_EVENT_ID_PMSUSPEND:
        ((virConnectDomainEventPMSuspendCallback)cb)(conn, dom, 0, cbopaque);
        goto cleanup;

    case VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE:
        ((virConnectDomainEventBalloonChangeCallback)cb)(conn, dom,
                                                         event->data.balloonChange.actual,
                                                         cbopaque);
        goto cleanup;

    case VIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK:
        ((virConnectDomainEventPMSuspendDiskCallback)cb)(conn, dom, 0, cbopaque);
        goto cleanup;

    case VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED:
        ((virConnectDomainEventDeviceRemovedCallback)cb)(conn, dom,
                                                         event->data.deviceRemoved.devAlias,
                                                         cbopaque);
        goto cleanup;

    case VIR_DOMAIN_EVENT_ID_LAST:
        break;
    }

    VIR_WARN("Unexpected event ID %d", eventID);

cleanup:
    virDomainFree(dom);
}


static int virDomainEventDispatchMatchCallback(virDomainEventPtr event,
                                               virObjectEventCallbackPtr cb)
{
    if (!cb)
        return 0;
    if (cb->deleted)
        return 0;
    if (cb->eventID != virObjectEventGetEventID(event))
        return 0;

    if (cb->meta) {
        /* Deliberately ignoring 'id' for matching, since that
         * will cause problems when a domain switches between
         * running & shutoff states & ignoring 'name' since
         * Xen sometimes renames guests during migration, thus
         * leaving 'uuid' as the only truly reliable ID we can use*/

        if (memcmp(event->meta.uuid, cb->meta->uuid, VIR_UUID_BUFLEN) == 0)
            return 1;

        return 0;
    } else {
        return 1;
    }
}


static void
virDomainEventDispatch(virDomainEventPtr event,
                       virObjectEventCallbackListPtr callbacks,
                       virObjectEventDispatchFunc dispatch,
                       void *opaque)
{
    size_t i;
    /* Cache this now, since we may be dropping the lock,
       and have more callbacks added. We're guaranteed not
       to have any removed */
    int cbCount = callbacks->count;

    for (i = 0; i < cbCount; i++) {
        if (!virDomainEventDispatchMatchCallback(event, callbacks->callbacks[i]))
            continue;

        (*dispatch)(callbacks->callbacks[i]->conn,
                    event,
                    callbacks->callbacks[i]->cb,
                    callbacks->callbacks[i]->opaque,
                    opaque);
    }
}


static void
virObjectEventQueueDispatch(virObjectEventQueuePtr queue,
                            virObjectEventCallbackListPtr callbacks,
                            virObjectEventDispatchFunc dispatch,
                            void *opaque)
{
    size_t i;

    for (i = 0; i < queue->count; i++) {
        virDomainEventDispatch(queue->events[i], callbacks, dispatch, opaque);
        virObjectUnref(queue->events[i]);
    }
    VIR_FREE(queue->events);
    queue->count = 0;
}

void
virObjectEventStateQueue(virObjectEventStatePtr state,
                         virDomainEventPtr event)
{
    if (state->timer < 0) {
        virObjectUnref(event);
        return;
    }

    virObjectEventStateLock(state);

    if (virObjectEventQueuePush(state->queue, event) < 0) {
        VIR_DEBUG("Error adding event to queue");
        virObjectUnref(event);
    }

    if (state->queue->count == 1)
        virEventUpdateTimeout(state->timer, 0);
    virObjectEventStateUnlock(state);
}


static void
virObjectEventStateDispatchFunc(virConnectPtr conn,
                                virDomainEventPtr event,
                                virConnectObjectEventGenericCallback cb,
                                void *cbopaque,
                                void *opaque)
{
    virObjectEventStatePtr state = opaque;

    /* Drop the lock whle dispatching, for sake of re-entrancy */
    virObjectEventStateUnlock(state);
    virDomainEventDispatchDefaultFunc(conn, event,
            VIR_DOMAIN_EVENT_CALLBACK(cb), cbopaque, NULL);
    virObjectEventStateLock(state);
}


static void
virObjectEventStateFlush(virObjectEventStatePtr state)
{
    virObjectEventQueue tempQueue;

    virObjectEventStateLock(state);
    state->isDispatching = true;

    /* Copy the queue, so we're reentrant safe when dispatchFunc drops the
     * driver lock */
    tempQueue.count = state->queue->count;
    tempQueue.events = state->queue->events;
    state->queue->count = 0;
    state->queue->events = NULL;
    virEventUpdateTimeout(state->timer, -1);

    virObjectEventQueueDispatch(&tempQueue,
                                state->callbacks,
                                virObjectEventStateDispatchFunc,
                                state);

    /* Purge any deleted callbacks */
    virObjectEventCallbackListPurgeMarked(state->callbacks);

    state->isDispatching = false;
    virObjectEventStateUnlock(state);
}


/**
 * virObjectEventStateRegisterID:
 * @conn: connection to associate with callback
 * @state: domain event state
 * @eventID: ID of the event type to register for
 * @cb: function to remove from event
 * @opaque: data blob to pass to callback
 * @freecb: callback to free @opaque
 * @callbackID: filled with callback ID
 *
 * Register the function @callbackID with connection @conn,
 * from @state, for events of type @eventID.
 *
 * Returns: the number of callbacks now registered, or -1 on error
 */
int
virObjectEventStateRegisterID(virConnectPtr conn,
                              virObjectEventStatePtr state,
                              unsigned char *uuid,
                              const char *name,
                              int id,
                              int eventID,
                              virConnectObjectEventGenericCallback cb,
                              void *opaque,
                              virFreeCallback freecb,
                              int *callbackID)
{
    int ret = -1;

    virObjectEventStateLock(state);

    if ((state->callbacks->count == 0) &&
        (state->timer == -1) &&
        (state->timer = virEventAddTimeout(-1,
                                           virDomainEventTimer,
                                           state,
                                           NULL)) < 0) {
        virReportError(VIR_ERR_INTERNAL_ERROR, "%s",
                       _("could not initialize domain event timer"));
        goto cleanup;
    }

    ret = virObjectEventCallbackListAddID(conn, state->callbacks,
                                          uuid, name, id, eventID, cb, opaque, freecb,
                                          callbackID);

    if (ret == -1 &&
        state->callbacks->count == 0 &&
        state->timer != -1) {
        virEventRemoveTimeout(state->timer);
        state->timer = -1;
    }

cleanup:
    virObjectEventStateUnlock(state);
    return ret;
}


/**
 * virDomainEventStateRegister:
 * @conn: connection to associate with callback
 * @state: object event state
 * @callback: function to remove from event
 * @opaque: data blob to pass to callback
 * @freecb: callback to free @opaque
 *
 * Register the function @callback with connection @conn,
 * from @state, for lifecycle events.
 *
 * Returns: the number of lifecycle callbacks now registered, or -1 on error
 */
int
virDomainEventStateRegister(virConnectPtr conn,
                            virObjectEventStatePtr state,
                            virConnectDomainEventCallback callback,
                            void *opaque,
                            virFreeCallback freecb)
{
    int ret = -1;

    virObjectEventStateLock(state);

    if ((state->callbacks->count == 0) &&
        (state->timer == -1) &&
        (state->timer = virEventAddTimeout(-1,
                                           virDomainEventTimer,
                                           state,
                                           NULL)) < 0) {
        virReportError(VIR_ERR_INTERNAL_ERROR, "%s",
                       _("could not initialize domain event timer"));
        goto cleanup;
    }

    ret = virDomainEventCallbackListAdd(conn, state->callbacks,
                                        callback, opaque, freecb);

    if (ret == -1 &&
        state->callbacks->count == 0 &&
        state->timer != -1) {
        virEventRemoveTimeout(state->timer);
        state->timer = -1;
    }

cleanup:
    virObjectEventStateUnlock(state);
    return ret;
}


/**
 * virDomainEventStateRegisterID:
 * @conn: connection to associate with callback
 * @state: object event state
 * @eventID: ID of the event type to register for
 * @cb: function to remove from event
 * @opaque: data blob to pass to callback
 * @freecb: callback to free @opaque
 * @callbackID: filled with callback ID
 *
 * Register the function @callbackID with connection @conn,
 * from @state, for events of type @eventID.
 *
 * Returns: the number of callbacks now registered, or -1 on error
 */
int
virDomainEventStateRegisterID(virConnectPtr conn,
                              virObjectEventStatePtr state,
                              virDomainPtr dom,
                              int eventID,
                              virConnectDomainEventGenericCallback cb,
                              void *opaque,
                              virFreeCallback freecb,
                              int *callbackID)
{
    if (dom)
        return virObjectEventStateRegisterID(conn, state, dom->uuid, dom->name,
                                             dom->id, eventID,
                                             VIR_OBJECT_EVENT_CALLBACK(cb),
                                             opaque, freecb, callbackID);
     else
        return virObjectEventStateRegisterID(conn, state, NULL, NULL, 0,
                                             eventID,
                                             VIR_OBJECT_EVENT_CALLBACK(cb),
                                             opaque, freecb, callbackID);
}


/**
 * virDomainEventStateDeregister:
 * @conn: connection to associate with callback
 * @state: object event state
 * @callback: function to remove from event
 *
 * Unregister the function @callback with connection @conn,
 * from @state, for lifecycle events.
 *
 * Returns: the number of lifecycle callbacks still registered, or -1 on error
 */
int
virDomainEventStateDeregister(virConnectPtr conn,
                              virObjectEventStatePtr state,
                              virConnectDomainEventCallback callback)
{
    int ret;

    virObjectEventStateLock(state);
    if (state->isDispatching)
        ret = virDomainEventCallbackListMarkDelete(conn,
                                                   state->callbacks, callback);
    else
        ret = virDomainEventCallbackListRemove(conn, state->callbacks, callback);

    if (state->callbacks->count == 0 &&
        state->timer != -1) {
        virEventRemoveTimeout(state->timer);
        state->timer = -1;
        virObjectEventQueueClear(state->queue);
    }

    virObjectEventStateUnlock(state);
    return ret;
}


/**
 * virObjectEventStateDeregisterID:
 * @conn: connection to associate with callback
 * @state: object event state
 * @callbackID: ID of the function to remove from event
 *
 * Unregister the function @callbackID with connection @conn,
 * from @state, for events.
 *
 * Returns: the number of callbacks still registered, or -1 on error
 */
int
virObjectEventStateDeregisterID(virConnectPtr conn,
                                virObjectEventStatePtr state,
                                int callbackID)
{
    int ret;

    virObjectEventStateLock(state);
    if (state->isDispatching)
        ret = virObjectEventCallbackListMarkDeleteID(conn,
                                                     state->callbacks, callbackID);
    else
        ret = virObjectEventCallbackListRemoveID(conn,
                                                 state->callbacks, callbackID);

    if (state->callbacks->count == 0 &&
        state->timer != -1) {
        virEventRemoveTimeout(state->timer);
        state->timer = -1;
        virObjectEventQueueClear(state->queue);
    }

    virObjectEventStateUnlock(state);
    return ret;
}


/**
 * virObjectEventStateEventID:
 * @conn: connection associated with the callback
 * @state: object event state
 * @callbackID: the callback to query
 *
 * Query what event ID type is associated with the
 * callback @callbackID for connection @conn
 *
 * Returns 0 on success, -1 on error
 */
int
virObjectEventStateEventID(virConnectPtr conn,
                           virObjectEventStatePtr state,
                           int callbackID)
{
    int ret;

    virObjectEventStateLock(state);
    ret = virObjectEventCallbackListEventID(conn,
                                            state->callbacks, callbackID);
    virObjectEventStateUnlock(state);
    return ret;
}
